## 第四课作业思路要点

#### 参考答案的思路

参考答案是在初始状态下把所有 token 的 owner 设定为合约的创建者地址，这也是通常的 ERC20 合约会使用的设计。

首先一定要注意到，transfer 和 transferFrom 函数是谁都可以调用的，这是 ERC20 标准的要求；所以在这种设计下，要实现题目要求，思路就是尽量减少重复检查，把大多数逻辑放到最根本的 transfer 和 transferFrom 函数中（因为我们增加的用来处理转账的函数，最终都是要调用这两个函数来做转账的，需要把这个逻辑想清楚）。另外，这两个函数是要有返回值的，如果你的程序没有显式的返回值，那这两个函数将总是返回 0（false），这会给可能的应用调用产生误解，需要注意这个问题。

题目的意图是希望大家在私募期内仅允许 owner 使用 transfer 来转账，仅允许代理人代理人使用 transferFrom 来转账。如果你允许代理人也使用 transfer 来转账也是可以的，但就要把这部分额度也一并计算到代理人的个人售卖额度限制和总售卖额度限制中（因为需求中还有单个地址持币上限的要求）。请仔细理解这个差别。

私募额度的限制条件只需要通过代理人累计转账数量（privateSalesReleased）和累计转账总数量（totalPrivateSalesReleased）来控制就可以了，要想明白的是 approve 的额度其实并不用关心，也不需要做额外的检查，这只是个“批准限额”而已。

私募结束之后，owner 可以选择 removeFromWhitelist，也可以不这么做，所以这个函数不应该加限制条件。参考答案里保留了私募限额的限制（即使过了私募期，只要私募代理人地址还在白名单里，就需要按照私募额度限制转账总额），但因为需求中并没有明确说明这个逻辑，所以其他的设计也是允许的。

在合约中处理 token 数量，应该用最小单位，这个思路类似于处理以太币都是用 Wei 来处理。因为 Solidity 中的除法是整数除法，会损失掉小于除数的所有精度（如果你除 10^18，那么就损失了这么多精度，这是不可接受的），所以要尽量避免使用除法。正确的处理方式是参考构造函数中的用法，对常量用乘以 10^18 的方式来处理。所有参数接收的 amount、value 都应该是以最小单位来计算的，也就是与 Wei 等价的单位（因为合约的 decimals 是 18），这点要牢记。所以在合约里定义常量时直接乘以 10^18 显然是更好的方式，因为这可以节省很多代码实际运行中去计算这个乘方的 gas 消耗。

#### 另一种实现思路

还有一种设计，可以在初始状态下将当前合约设定为所有 token 的 owner，这样就相当于将所有 token 先锁定在了当前合约中。

在这种思路下，就需要增加一个 onlyOwner 的函数，来供管理员提取 token，同时考虑私募期和其后的正常运作期间。

这种思路的代码实现更加简单明了，因为所有 token 都是锁定在合约地址的，所以 tranfer 和 transferFrom 函数就相应简化了（因为合约管理员和私募代理人都不可能直接使用这两个函数来进行转账了，所以不需要考虑参考答案里这两个函数中那些检查处理了）。

#### 两种思路的差别

对这个题目来讲，两种实现的差别大概仅在合约管理员调用的函数以及私募期的日志信息。参考答案中私募期的日志信息将会是由合约管理员地址发出的 transfer 和 transferFrom，而第二种方案在私募期的日志信息将只会有由合约地址发出的 transfer。

这里需要再次说明，通常的 ERC20 合约，会在构造函数时将所有 token 设定为合约创建者地址所有（即参考答案的设计），但在做私募、公募或其他固定份额的分发时，会由合约创建者从自己的地址上将对应数量的 token 转到相应的私募合约、公募合约和其他固定份额销售合约中锁定，由那个合约来单独管理（即第二种方案的思路）。这也是推荐的最佳实践。（这个题目里的设计方式仅在业务逻辑非常简单时可以采用，但通常不推荐。）

对于这个题目，无论从代码量还是逻辑复杂程度来讲，第二种方案都显然更好。
